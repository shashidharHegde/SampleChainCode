/* 2 Copyright IBM Corp 2016 All Rights Reserved. 3  4 Licensed under the Apache License, Version 2.0 (the "License"); 5 you may not use this file except in compliance with the License. 6 You may obtain a copy of the License at 7  8    http://www.apache.org/licenses/LICENSE-2.0 9  10 Unless required by applicable law or agreed to in writing, software 11 distributed under the License is distributed on an "AS IS" BASIS, 12 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 13 See the License for the specific language governing permissions and 14 limitations under the License. 15 */ 16  17 package main 18  19 import ( 20  "errors" 21  "fmt" 22  "strconv" 23  24  "github.com/hyperledger/fabric/core/chaincode/shim" 25 ) 26  27 // SimpleChaincode example simple Chaincode implementation 28 type SimpleChaincode struct { 29 } 30  31 func main() { 32  err := shim.Start(new(SimpleChaincode)) 33  if err != nil { 34   fmt.Println("Error starting Simple chaincode: %s", err) 35  } 36 } 37  38 // Init resets all the things 39 func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { 40  if len(args) != 1 { 41   return nil, errors.New("Incorrect number of arguments. Expecting 1") 42  } 43  44  err := stub.PutState("hello_world", []byte(args[0])) 45  if err != nil { 46   return nil, err 47  } 48  49  return nil, nil 50 } 51  52 // Invoke isur entry point to invoke a chaincode function 53 func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { 54  fmt.Println("invoke is running " + function) 55  56  // Handle different functions 57  if function == "transfer" { 58   // Transaction makes payment of X units from A to B 59   fmt.Println("Function is transfer") 60   return t.transfer(stub, args) 61  } else if function == "init" { 62   fmt.Println("Function is init") 63   return t.Init(stub, function, args) 64  } else if function == "write" { 65   fmt.Println("Function is write") 66   return t.write(stub, args) 67  } else if function == "delete" { 68   // Deletes an entity from its state 69   fmt.Println("Function is delete") 70   return t.delete(stub, args) 71  } 72  fmt.Println("invoke did not find func: " + function) 73  74  return nil, errors.New("Received unknown function invocation: " + function) 75 } 76 func (t *SimpleChaincode) write(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) { 77   78  var A, B string    // Entities 79  var Aval, Bval int // Values 80  var err error 81  82  if len(args) != 4 { 83   return nil, errors.New("Incorrect number of arguments. Expecting 4") 84  } 85  86  // Initialize the chaincode 87  A = args[0] 88  Aval, err = strconv.Atoi(args[1]) 89  if err != nil { 90   return nil, errors.New("Expecting integer value for asset holding") 91  } 92  B = args[2] 93  Bval, err = strconv.Atoi(args[3]) 94  if err != nil { 95   return nil, errors.New("Expecting integer value for asset holding") 96  } 97    98  fmt.Println("Aval = %d, Bval = %d\n", Aval, Bval) 99  100  // Write the state to the ledger 101  err = stub.PutState(A, []byte(strconv.Itoa(Aval))) 102  if err != nil { 103   return nil, err 104  } 105  106  err = stub.PutState(B, []byte(strconv.Itoa(Bval))) 107  if err != nil { 108   return nil, err 109  } 110  111   112  return nil, nil 113 } 114  115 // Transaction makes payment of X units from A to B 116 func (t *SimpleChaincode) transfer(stub *shim.ChaincodeStubInterface, args []string) ([]byte, error) { 117  fmt.Println("Running transfer") 118   119  var A, B string    // Entities 120  var Aval, Bval int // Asset holdings 121  var X int          // Transaction value 122  var err error 123  124  if len(args) != 3 { 125   return nil, errors.New("Incorrect number of arguments. Expecting 3") 126  } 127  128  A = args[0] 129  B = args[1] 130  131  // Get the state from the ledger 132  Avalbytes, err := stub.GetState(A) 133  if err != nil { 134   return nil, errors.New("Failed to get state") 135  } 136  if Avalbytes == nil { 137   return nil, errors.New("Entity not found") 138  } 139  Aval, _ = strconv.Atoi(string(Avalbytes)) 140  141  Bvalbytes, err := stub.GetState(B) 142  if err != nil { 143   return nil, errors.New("Failed to get state") 144  } 145  if Bvalbytes == nil { 146   return nil, errors.New("Entity not found") 147  } 148  Bval, _ = strconv.Atoi(string(Bvalbytes)) 149  150  // Perform the execution 151  X, err = strconv.Atoi(args[2]) 152  Aval = Aval - X 153  Bval = Bval + X 154  fmt.Println("Aval = %d, Bval = %d\n", Aval, Bval) 155  156  // Write the state back to the ledger 157  err = stub.PutState(A, []byte(strconv.Itoa(Aval))) 158  if err != nil { 159   return nil, err 160  } 161  162  err = stub.PutState(B, []byte(strconv.Itoa(Bval))) 163  if err != nil { 164   return nil, err 165  } 166  167  return nil, nil 168 } 169  170 // Deletes an entity from state 171 func (t *SimpleChaincode) delete(stub *shim.ChaincodeStubInterface, args []string) ([]byte, error) { 172  fmt.Println("Running delete") 173   174  if len(args) != 1 { 175   return nil, errors.New("Incorrect number of arguments. Expecting 3") 176  } 177  178  A := args[0] 179  180  // Delete the key from the state in ledger 181  err := stub.DelState(A) 182  if err != nil { 183   return nil, errors.New("Failed to delete state") 184  } 185  186  return nil, nil 187 }  188  189 // Query is our entry point for queries 190 func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) { 191  fmt.Println("query is running " + function) 192  193  // Handle different functions 194  if function == "read" { //read a variable 195   return t.read(stub, args) 196  } 197  fmt.Println("query did not find func: " + function) 198  199  return nil, errors.New("Received unknown function query: " + function) 200 } 201  202  203 // read - query function to read key/value pair 204 func (t *SimpleChaincode) read(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) { 205  var A, jsonResp string 206  var err error 207  208  if len(args) != 1 { 209   return nil, errors.New("Incorrect number of arguments. Expecting name of the key to query") 210  } 211  212  A = args[0] 213  Avalbytes, err := stub.GetState(A) 214  if err != nil { 215   jsonResp = "{\"Error\":\"Failed to get state for " + A + "\"}" 216   return nil, errors.New(jsonResp) 217  } 218  219  return Avalbytes, nil 220 } 

